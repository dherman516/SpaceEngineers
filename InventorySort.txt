// Space Engineers Inventory Manager (Legacy C# Compatible)
// Author: Copilot (customized for Dave)

List<IMyTerminalBlock> allBlocks = new List<IMyTerminalBlock>();
List<IMyCargoContainer> cargo = new List<IMyCargoContainer>();
List<IMyRefinery> refineries = new List<IMyRefinery>();

int tickCounter = 0;
 const int RUN_INTERVAL = 38; // ~60 seconds

public Program()
{
    Runtime.UpdateFrequency = UpdateFrequency.Update100;
}

public void Main(string arg, UpdateType updateSource)
{
   tickCounter++; 
   if (tickCounter < RUN_INTERVAL)
           return;
    tickCounter = 0; // reset    


   GridTerminalSystem.GetBlocksOfType(allBlocks, SameGrid);

    cargo.Clear();
    refineries.Clear();

    // Collect cargo containers and refineries
    for (int i = 0; i < allBlocks.Count; i++)
    {
        var b = allBlocks[i];

        var cargoBlock = b as IMyCargoContainer;
        if (cargoBlock != null)
            cargo.Add(cargoBlock);

        var refineryBlock = b as IMyRefinery;
        if (refineryBlock != null)
            refineries.Add(refineryBlock);
    }

    // Sort cargo by largest capacity
cargo.Sort((a, b) =>
{
    float aCap = (float)a.GetInventory().MaxVolume;
    float bCap = (float)b.GetInventory().MaxVolume;
    return bCap > aCap ? 1 : (bCap < aCap ? -1 : 0);
});


    // Process all inventories except refinery input
    for (int i = 0; i < allBlocks.Count; i++)
    {
        var block = allBlocks[i];

        // Skip refineries here (handled separately)
        if (block is IMyRefinery)
            continue;

        int invCount = block.InventoryCount;
        for (int invIndex = 0; invIndex < invCount; invIndex++)
        {
            var inv = block.GetInventory(invIndex);
            MoveItems(inv);
        }
    }

    // Process refinery inventories (only move non-mineables)
    for (int i = 0; i < refineries.Count; i++)
    {
        var r = refineries[i];
        var inv = r.GetInventory(0);
        MoveNonMineables(inv);
    }
}

bool SameGrid(IMyTerminalBlock b)
{
    return b.IsSameConstructAs(Me);
}

bool IsMineable(MyInventoryItem item)
{
    string type = item.Type.TypeId;
    string sub = item.Type.SubtypeId;

    // Ore except Ice
    if (type.IndexOf("Ore") != -1 && sub != "Ice")
        return true;

    // Ingots
    if (type.IndexOf("Ingot") != -1)
        return true;

    return false;
}

void MoveItems(IMyInventory from)
{
    var items = new List<MyInventoryItem>();
    from.GetItems(items);

    for (int i = 0; i < items.Count; i++)
    {
        var item = items[i];

        if (IsMineable(item))
        {
            MoveToRefinery(from, item);
        }
        else
        {
            MoveToCargo(from, item);
        }
    }
}

void MoveNonMineables(IMyInventory from)
{
    var items = new List<MyInventoryItem>();
    from.GetItems(items);

    for (int i = 0; i < items.Count; i++)
    {
        var item = items[i];

        if (!IsMineable(item))
        {
            MoveToCargo(from, item);
        }
    }
}

void MoveToRefinery(IMyInventory from, MyInventoryItem item)
{
    for (int i = 0; i < refineries.Count; i++)
    {
        var inv = refineries[i].GetInventory(0);
        if (from.TransferItemTo(inv, item))
            return;
    }
}

void MoveToCargo(IMyInventory from, MyInventoryItem item)
{
    for (int i = 0; i < cargo.Count; i++)
    {
        var inv = cargo[i].GetInventory();
        if (from.TransferItemTo(inv, item))
            return;
    }
}
