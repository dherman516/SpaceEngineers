// =============================================================
//  RoverAutoExcavation_Rewrite_ForwardSafe_Optimized.cs
//  - STOP-safe
//  - Forward-only arm option
//  - Collision envelope to avoid hitting rover
//  - WASD restore, gyro=3.0 when idle
//  - Mode3 removed
// =============================================================


// ======================= CONFIG =======================

// Block names
const string ROTOR_NAME        = "Drill-Rotor";
const string PISTON_EXT_NAME   = "Drill-Piston-Upper";
const string PISTON_THIRD_NAME = "Drill-Piston-Third";
const string PISTON_FINAL_NAME = "Drill-Piston-Final";
const string HINGE_MAIN_NAME   = "Drill-Hinge-First";
const string HINGE_TIP_NAME    = "Drill-Hinge-Second";
const string DRILL_NAME        = "Drill";

// Cargo container (empty = auto-detect all)
const string CARGO_NAME = "";

// Geometry tolerances
const float  ANGLE_TOL_DEG = 1.0f;
const double POS_TOL_M     = 0.01;

// Safe zone (legacy main hinge back-limit; still used as last resort)
const float SAFE_MAIN_HINGE_MIN_DEG = -150f;

// Home pose
const float HINGE_MAIN_HOME_DEG = -90f;   // matches your -158Â° orientation better
const float HINGE_TIP_HOME_DEG  = 0f;
const float ROTOR_HOME_DEG      = 0f;

const double EXT_PISTON_HOME_POS_M   = 0.0;
const double THIRD_PISTON_HOME_POS_M = 0.0;
const double FINAL_PISTON_HOME_POS_M = 0.0;

// Piston max lengths
const double EXT_PISTON_WORK_POS_M   = 2.0;
const double THIRD_PISTON_WORK_POS_M = 2.0;
const double FINAL_PISTON_WORK_POS_M = 2.0;


// ======================= MODE CONFIG =======================

// Mode1 simplified sweep-first
const float MODE1_HINGE_MAIN_DEG = -90f;
const float MODE1_HINGE_TIP_DEG  = -60f;

const double MODE1_START_EXT_M = 0.0;
const double MODE1_STEP_EXT_M  = 0.2;
const double MODE1_MAX_EXT_M   = 4.0;

const float MODE1_LEFT_DEG  = 60f;
const float MODE1_RIGHT_DEG = -60f;
const float MODE1_SWEEP_RPM = 1.0f;

// Mode2 hill removal
const float MODE2_LEFT_DEG       = 60f;
const float MODE2_RIGHT_DEG      = 120f;
const float MODE2_START_MAIN_DEG = -10f;
const float MODE2_END_MAIN_DEG   = -70f;
const float MODE2_STEP_MAIN_DEG  = -10f;
const float MODE2_HINGE_TIP_DEG  = 0f;
const float MODE2_SWEEP_RPM      = 0.35f;

// Fullness detection
const double FULLNESS_DELTA_EPS     = 0.0005;
const double FULLNESS_STABLE_TIME_S = 10.0;
const double FULL_THRESHOLD         = 0.99;

// Status update interval
const double STATUS_INTERVAL_S = 0.5;


// ======================= FORWARD-ONLY + COLLISION ENVELOPE =======================

const bool FORWARD_ONLY_ARM = true;
const bool COLLISION_ENVELOPE = true;

const float FORWARD_MAX_ROTOR_DEG = 100f;

const float HINGE_MAIN_MIN_DEG = -170f;
const float HINGE_MAIN_MAX_DEG = 170f;

const float BODY_BACK_LIMIT_DEG = -120f;
const double BODY_NEAR_EXTENSION_M = 0.8;


// ======================= DEBUG & TRACE =======================

string debug = "";
void DBG(string s) { debug += s + "\n"; }

void TRACE(string msg)
{
    Echo("[TRACE] " + msg);
}

string lastAbortReason = "";


// ======================= INTERNAL STATE =======================

IMyMotorStator rotor;
IMyPistonBase pistonExt;
IMyPistonBase pistonThird;
IMyPistonBase pistonFinal;
IMyMotorStator hingeMain;
IMyMotorStator hingeTip;
IMyShipDrill drill;

List<IMyCargoContainer> cargos = new List<IMyCargoContainer>();
List<IMyMotorSuspension> wheels = new List<IMyMotorSuspension>();
List<IMyGyro> gyros = new List<IMyGyro>();
List<IMyThrust> downThrusters = new List<IMyThrust>();
IMyShipController ctrl;

IMyTextSurface lcd;

float manualMainRad  = 0f;
float manualTipRad   = 0f;
float manualRotorRad = 0f;
float manualPExt     = 0f;
float manualPThird   = 0f;
float manualPFinal   = 0f;

enum GlobalMode { None, Mode1, Mode2, Move }
enum ArmState {
    Idle, Homing, ManualMove,
    Mode1_Init, Mode1_Sweep, Mode1_Return,
    Mode2_Init, Mode2_Lower, Mode2_Sweep, Mode2_RaiseAngle, Mode2_CheckStopAngle, Mode2_Return
}
enum TestPose {
    None, VerticalHome, RotorLeft, RotorRight, Folded,
    ExtendedForward, PistonExt, PistonThird, PistonFinal, FullExtension, Done
}
enum Mode1EndAction { Stop, Repeat }

GlobalMode currentMode = GlobalMode.None;
ArmState state = ArmState.Idle;
TestPose testPose = TestPose.None;
Mode1EndAction mode1EndAction = Mode1EndAction.Stop;

bool IsTestMode() => testPose != TestPose.None;

double lastStatusTime = 0;
bool stopRequested = false;
bool drillEnabledForMode = true;

// Mode1 internal
bool mode1SweepDirPositive = true;
float mode1TargetRotorRad = 0f;
double mode1LastFullness = 0.0;
double mode1FullnessStableTime = 0.0;
double mode1CurrentExt = MODE1_START_EXT_M;
bool mode1PassedRight = false;

// Mode2 internal
float mode2CurrentMainDeg = MODE2_START_MAIN_DEG;
bool mode2SweepDirPositive = true;
float mode2TargetRotorRad = 0f;
double mode2LastFullness = 0.0;
double mode2FullnessStableTime = 0.0;


// ======================= SUSPENSION CONTROL =======================

void FindWheels() {
    wheels.Clear();
    GridTerminalSystem.GetBlocksOfType(wheels, w => w.CubeGrid == Me.CubeGrid);
}

void ResetWheels() {
    foreach (var w in wheels) {
        w.Strength = 50f;
        w.Height   = 0.0f;
        w.Power    = 1.0f;
        w.Friction = 1.0f;
        w.Brake    = false;
        w.PropulsionOverride = 0f;
        w.SteeringOverride   = 0f;
    }
}

void LowerCenterOfGravity() {
    foreach (var w in wheels) {
        w.Strength = 100f;
        w.Height   = -0.2f;
        w.Power    = 1.0f;
        w.Friction = 1.5f;
    }
}

void RestoreDrive()
{
    ResetWheels();

    foreach (var g in gyros) {
        if (g == null) continue;
        g.GyroOverride = false;
        g.Yaw = g.Pitch = g.Roll = 0f;
        g.GyroPower = 3f; // your chosen value
    }

    if (ctrl != null)
        ctrl.HandBrake = false;
}

void ResetEntireGrid()
{
    var blocks = new List<IMyTerminalBlock>();
    GridTerminalSystem.GetBlocks(blocks);

    foreach (var b in blocks)
    {
        // Wheels
        var wheel = b as IMyMotorSuspension;
        if (wheel != null)
        {
            wheel.Brake = false;
            wheel.PropulsionOverride = 0f;
            wheel.SteeringOverride = 0f;
            wheel.Power = 1f;
            wheel.Friction = 1f;
            wheel.Strength = 50f;
            wheel.Height = 0f;
            continue;
        }

        // Gyros
        var gyro = b as IMyGyro;
        if (gyro != null)
        {
            gyro.GyroOverride = false;
            gyro.Yaw = gyro.Pitch = gyro.Roll = 0f;
            gyro.GyroPower = 3f;   // your chosen value
            continue;
        }

        // Thrusters
        var thr = b as IMyThrust;
        if (thr != null)
        {
            thr.ThrustOverride = 0f;
            thr.ThrustOverridePercentage = 0f;
            continue;
        }

        // Cockpits / RC blocks
        var ctrl = b as IMyShipController;
        if (ctrl != null)
        {
            ctrl.HandBrake = false;
            ctrl.DampenersOverride = true;
            ctrl.ControlThrusters = false;
            ctrl.ControlWheels = true;
            continue;
        }

        // Rotors / Hinges
        var rotor = b as IMyMotorStator;
        if (rotor != null)
        {
            rotor.TargetVelocityRPM = 0f;
            rotor.RotorLock = false;
            continue;
        }

        // Pistons
        var piston = b as IMyPistonBase;
        if (piston != null)
        {
            piston.Velocity = 0f;
            continue;
        }

        // Connectors
        var conn = b as IMyShipConnector;
        if (conn != null)
        {
            if (conn.Status == MyShipConnectorStatus.Connected ||
                conn.Status == MyShipConnectorStatus.Connectable)
            {
                conn.Disconnect();
            }
            continue;
        }

        // Merge blocks
        var merge = b as IMyShipMergeBlock;
        if (merge != null)
        {
            merge.Enabled = true;
            continue;
        }
    }

    Echo("Full grid reset complete.");
}

// ======================= PROGRAM START =======================

public Program() {
    Runtime.UpdateFrequency = UpdateFrequency.Update10;

    lcd = Me.GetSurface(0);
    lcd.ContentType = VRage.Game.GUI.TextPanel.ContentType.TEXT_AND_IMAGE;
    lcd.FontSize = 1.0f;
    lcd.Font = "Monospace";

    FindBlocks(true);
    FindWheels();
    ResetWheels();
}


// ======================= MAIN LOOP =======================
public void Main(string argument, UpdateType updateSource)
{
    TRACE("Main tick");

    if (!string.IsNullOrWhiteSpace(argument))
    {
        TRACE("Command received: " + argument);
        HandleCommand(argument.Trim().ToLower());
    }

    if (stopRequested)
    {
        TRACE("STOP active -- skipping logic");
        UpdateStatus(Runtime.TimeSinceLastRun.TotalSeconds);
        return;
    }

    if (!EnsureBlocks())
    {
        TRACE("EnsureBlocks FAILED");
        Abort("Missing required blocks");
        UpdateStatus(0.016);
        return;
    }

    double dt = Runtime.TimeSinceLastRun.TotalSeconds;
    if (dt <= 0) dt = 0.016;

    if (state != ArmState.Idle)
    {
        TRACE("Safety checks");
        CheckSafeZone();
        if (COLLISION_ENVELOPE)
            CheckCollisionEnvelope();
    }

    if (state != ArmState.Idle)
    {
        TRACE("Running state machine: " + state);
        UpdateStateMachine(dt);
    }

    UpdateStatus(dt);
}


// ======================= STOP / ABORT =======================

void Abort(string reason) {
    lastAbortReason = reason;
    FullStop();
    ResetWheels();
    currentMode = GlobalMode.None;
    state = ArmState.Idle;
    stopRequested = true; // stays locked until a new command
    TRACE("ABORT: " + reason);
}

void ZeroGyros() {
    foreach (var g in gyros) {
        if (g == null) continue;
        g.GyroOverride = false;
        g.Yaw = g.Pitch = g.Roll = 0f;
        g.GyroPower = 0f;
    }
}

void ZeroThrusters() {
    foreach (var t in downThrusters) {
        t.ThrustOverridePercentage = 0f;
        t.ThrustOverride = 0f;
    }
}

void ZeroWheelOverrides() {
    foreach (var w in wheels) {
        w.PropulsionOverride = 0f;
        w.SteeringOverride   = 0f;
        w.Brake = true;
    }
}

void FullStop() {
    if (rotor != null) rotor.TargetVelocityRPM = 0f;
    if (hingeMain != null) hingeMain.TargetVelocityRPM = 0f;
    if (hingeTip  != null) hingeTip.TargetVelocityRPM  = 0f;

    if (pistonExt   != null) pistonExt.Velocity   = 0f;
    if (pistonThird != null) pistonThird.Velocity = 0f;
    if (pistonFinal != null) pistonFinal.Velocity = 0f;

    if (drill != null) drill.Enabled = false;

    ZeroGyros();
    ZeroThrusters();
    ZeroWheelOverrides();

    if (ctrl != null)
        ctrl.HandBrake = true;
}


// ======================= COMMAND HANDLER =======================

void HandleCommand(string arg) {

    TRACE("HandleCommand: " + arg);
    stopRequested = false;
    lastAbortReason = "";
    if (arg == "resetgrid") { 
         ResetEntireGrid();
         return; 
    }
    if (arg == "stop") {
        FullStop();
        ResetWheels();
        stopRequested = true;
        currentMode = GlobalMode.None;
        state = ArmState.Idle;
        lastAbortReason = "STOP command";
        return;
    }

    if (arg.StartsWith("move ")) {
        FullStop();
        ResetWheels();
        LowerCenterOfGravity();
        ParseManualMoveCommand(arg);
        ApplyForwardConstraint(ref manualMainRad, ref manualRotorRad);
        currentMode = GlobalMode.Move;
        state = ArmState.ManualMove;
        return;
    }

    if (arg.StartsWith("mode1")) {
        drillEnabledForMode = !arg.Contains("nodrill");
        mode1EndAction = arg.Contains("repeat") ? Mode1EndAction.Repeat : Mode1EndAction.Stop;
        FullStop();
        ResetWheels();
        LowerCenterOfGravity();
        currentMode = GlobalMode.Mode1;
        state = ArmState.Homing;
        return;
    }

    if (arg.StartsWith("mode2")) {
        drillEnabledForMode = !arg.Contains("nodrill");
        FullStop();
        ResetWheels();
        LowerCenterOfGravity();
        currentMode = GlobalMode.Mode2;
        mode2CurrentMainDeg = MODE2_START_MAIN_DEG;
        state = ArmState.Homing;
        return;
    }

    if (arg == "home") {
        FullStop();
        ResetWheels();
        LowerCenterOfGravity();
        currentMode = GlobalMode.None;
        state = ArmState.Homing;
        return;
    }

    if (arg == "test") {
        FullStop();
        ResetWheels();
        LowerCenterOfGravity();
        testPose = TestPose.VerticalHome;
        currentMode = GlobalMode.Move;
        AdvanceTestPose();
        return;
    }
}


// ======================= SAFE ZONE & COLLISION ENVELOPE =======================

void CheckSafeZone()
{
    if (hingeMain == null) return;

    float hingeDeg = RadToDeg(hingeMain.Angle);

    if (hingeDeg < SAFE_MAIN_HINGE_MIN_DEG)
    {
        Abort($"SAFE ZONE VIOLATION: Main hinge too far back! ({hingeDeg:F1} deg)");
    }
}

double GetTotalExtension()
{
    double e = pistonExt?.CurrentPosition ?? 0.0;
    double t = pistonThird?.CurrentPosition ?? 0.0;
    double f = pistonFinal?.CurrentPosition ?? 0.0;
    return e + t + f;
}

void CheckCollisionEnvelope()
{
    if (hingeMain == null) return;

    float hingeDeg = RadToDeg(hingeMain.Angle);
    double ext = GetTotalExtension();

    if (hingeDeg < HINGE_MAIN_MIN_DEG || hingeDeg > HINGE_MAIN_MAX_DEG)
    {
        Abort($"Collision envelope: hingeMain out of bounds ({hingeDeg:F1} deg)");
        return;
    }

    if (hingeDeg < BODY_BACK_LIMIT_DEG && ext < BODY_NEAR_EXTENSION_M)
    {
        Abort($"Collision envelope: arm behind and close (hinge={hingeDeg:F1}, ext={ext:F2})");
        return;
    }
}


// ======================= STATE MACHINE =======================

void UpdateStateMachine(double dt)
{
    TRACE("UpdateStateMachine: " + state);
    switch (state)
    {
        case ArmState.Idle:
            break;

        case ArmState.Homing:
            HomingState();
            break;

        case ArmState.ManualMove:
            ManualMoveState();
            break;

        case ArmState.Mode1_Init:
            Mode1_Init();
            break;

        case ArmState.Mode1_Sweep:
            Mode1_Sweep(dt);
            break;

        case ArmState.Mode1_Return:
            Mode1_Return();
            break;

        case ArmState.Mode2_Init:
            Mode2_Init();
            break;

        case ArmState.Mode2_Lower:
            Mode2_Lower(dt);
            break;

        case ArmState.Mode2_Sweep:
            Mode2_Sweep(dt);
            break;

        case ArmState.Mode2_RaiseAngle:
            Mode2_RaiseAngle();
            break;

        case ArmState.Mode2_CheckStopAngle:
            Mode2_CheckStopAngle();
            break;

        case ArmState.Mode2_Return:
            Mode2_Return();
            break;
    }
}


// ======================= HOMING =======================

void HomingState()
{
    bool rHome      = MoveRotorToAngle(rotor, DegToRad(ROTOR_HOME_DEG));
    bool pFinalHome = MovePistonTo(pistonFinal, (float)FINAL_PISTON_HOME_POS_M, false);
    bool pThirdHome = MovePistonTo(pistonThird, (float)THIRD_PISTON_HOME_POS_M, false);
    bool pExtHome   = MovePistonTo(pistonExt,   (float)EXT_PISTON_HOME_POS_M,   false);
    bool hTipHome   = MoveHingeToAngle(hingeTip,   DegToRad(HINGE_TIP_HOME_DEG));
    bool hMainHome  = MoveHingeToAngle(hingeMain, DegToRad(HINGE_MAIN_HOME_DEG));

    drill.Enabled = false;

    if (rHome && pFinalHome && pThirdHome && pExtHome && hTipHome && hMainHome)
    {
        TRACE("Homing complete, switching mode: " + currentMode);
        switch (currentMode)
        {
            case GlobalMode.Mode1:
                PrepareMode1();
                break;

            case GlobalMode.Mode2:
                PrepareMode2();
                break;

            default:
                RestoreDrive();
                state = ArmState.Idle;
                break;
        }
    }
}


// ======================= MANUAL MOVE =======================

void ManualMoveState()
{
    bool hMain  = MoveHingeToAngle(hingeMain, manualMainRad);
    bool hTip   = MoveHingeToAngle(hingeTip,  manualTipRad);
    bool rDone  = MoveRotorToAngle(rotor, manualRotorRad, 0.5f);

    bool pExt   = MovePistonTo(pistonExt,   manualPExt,   false);
    bool pThird = MovePistonTo(pistonThird, manualPThird, false);
    bool pFinal = MovePistonTo(pistonFinal, manualPFinal, false);

    if (hMain && hTip && rDone && pExt && pThird && pFinal)
    {
        FullStop();
        RestoreDrive();
        state = ArmState.Idle;

        if (testPose != TestPose.None)
            AdvanceTestPose();
        else
            currentMode = GlobalMode.None;
    }
}


// ======================= MODE 1 =======================

void PrepareMode1()
{
    mode1SweepDirPositive = true;
    mode1TargetRotorRad   = DegToRad(MODE1_LEFT_DEG);

    mode1LastFullness       = GetTotalFullness();
    mode1FullnessStableTime = 0.0;

    mode1CurrentExt = MODE1_START_EXT_M;
    mode1PassedRight = false;

    state = ArmState.Mode1_Init;
}

void Mode1_Init()
{
    bool rLeft     = MoveRotorToAngle(rotor, DegToRad(MODE1_LEFT_DEG));
    bool pExtPos   = MovePistonTo(pistonExt,   0.0f, false);
    bool pThirdPos = MovePistonTo(pistonThird, 0.0f, false);
    bool pFinalPos = MovePistonTo(pistonFinal, 0.0f, false);
    bool hMainPos  = MoveHingeToAngle(hingeMain, DegToRad(MODE1_HINGE_MAIN_DEG));
    bool hTipPos   = MoveHingeToAngle(hingeTip,  DegToRad(MODE1_HINGE_TIP_DEG));

    drill.Enabled = false;

    if (rLeft && pExtPos && pThirdPos && pFinalPos && hMainPos && hTipPos)
    {
        mode1TargetRotorRad  = DegToRad(MODE1_RIGHT_DEG);
        mode1SweepDirPositive = true;
        mode1LastFullness = GetTotalFullness();
        mode1FullnessStableTime = 0.0;
        mode1PassedRight = false;

        drill.Enabled = drillEnabledForMode;
        state = ArmState.Mode1_Sweep;
    }
}

void Mode1_Sweep(double dt)
{
    double fullness = GetTotalFullness();

    if (fullness >= FULL_THRESHOLD)
    {
        drill.Enabled = false;
        state = ArmState.Mode1_Return;
        return;
    }

    MoveHingeToAngle(hingeMain, DegToRad(MODE1_HINGE_MAIN_DEG));
    MoveHingeToAngle(hingeTip,  DegToRad(MODE1_HINGE_TIP_DEG));
    MovePistonTo(pistonExt, (float)EXT_PISTON_WORK_POS_M, false);

    SetMode1Extension(mode1CurrentExt);

    const float DEAD = 0.02f;
    float cur = rotor.Angle;
    float diff = mode1TargetRotorRad - cur;

    if (Math.Abs(diff) <= DEAD)
    {
        rotor.TargetVelocityRPM = 0f;

        float curDeg = RadToDeg(cur);

        if (Math.Abs(curDeg - MODE1_RIGHT_DEG) < 3f)
            mode1PassedRight = true;

        if (Math.Abs(curDeg - MODE1_LEFT_DEG) < 3f && mode1PassedRight)
        {
            mode1PassedRight = false;
            mode1CurrentExt += MODE1_STEP_EXT_M;

            if (mode1CurrentExt > MODE1_MAX_EXT_M)
            {
                drill.Enabled = false;
                state = ArmState.Mode1_Return;
                return;
            }
        }

        mode1SweepDirPositive = !mode1SweepDirPositive;
        mode1TargetRotorRad = DegToRad(mode1SweepDirPositive ? MODE1_RIGHT_DEG : MODE1_LEFT_DEG);
    }
    else
    {
        float baseRpm = IsTestMode() ? 2.0f : MODE1_SWEEP_RPM;
        float speed = baseRpm;

        if (Math.Abs(diff) < DegToRad(10f))
            speed = Math.Max(0.5f, baseRpm * 0.5f);

        rotor.TargetVelocityRPM = diff > 0 ? speed : -speed;
    }

    drill.Enabled = drillEnabledForMode;

    double combined = fullness;
    double delta = combined - mode1LastFullness;

    if (delta > FULLNESS_DELTA_EPS)
    {
        mode1LastFullness = combined;
        mode1FullnessStableTime = 0.0;
    }
    else
    {
        mode1FullnessStableTime += dt;

        if (mode1FullnessStableTime >= FULLNESS_STABLE_TIME_S)
        {
            drill.Enabled = false;
            state = ArmState.Mode1_Return;
        }
    }
}

void SetMode1Extension(double totalExt)
{
    totalExt = Math.Max(0.0, Math.Min(MODE1_MAX_EXT_M, totalExt));

    double thirdTarget = Math.Min(totalExt, THIRD_PISTON_WORK_POS_M);
    double finalTarget = Math.Max(0.0, totalExt - thirdTarget);
    finalTarget = Math.Min(finalTarget, FINAL_PISTON_WORK_POS_M);

    MovePistonTo(pistonThird, (float)thirdTarget, false);
    MovePistonTo(pistonFinal, (float)finalTarget, false);
}

void Mode1_Return()
{
    bool rHome      = MoveRotorToAngle(rotor, DegToRad(ROTOR_HOME_DEG));
    bool pFinalHome = MovePistonTo(pistonFinal, (float)FINAL_PISTON_HOME_POS_M, false);
    bool pThirdHome = MovePistonTo(pistonThird, (float)THIRD_PISTON_HOME_POS_M, false);
    bool pExtHome   = MovePistonTo(pistonExt,   (float)EXT_PISTON_HOME_POS_M,   false);
    bool hTipHome   = MoveHingeToAngle(hingeTip,  DegToRad(HINGE_TIP_HOME_DEG));
    bool hMainHome  = MoveHingeToAngle(hingeMain, DegToRad(HINGE_MAIN_HOME_DEG));

    drill.Enabled = false;

    if (rHome && pFinalHome && pThirdHome && pExtHome && hTipHome && hMainHome)
    {
        FullStop();
        RestoreDrive();

        if (mode1EndAction == Mode1EndAction.Repeat)
        {
            LowerCenterOfGravity();
            PrepareMode1();
        }
        else
        {
            state = ArmState.Idle;
            currentMode = GlobalMode.None;
        }
    }
}


// ======================= MODE 2 =======================

void PrepareMode2()
{
    mode2SweepDirPositive = true;
    mode2TargetRotorRad = DegToRad(MODE2_LEFT_DEG);

    mode2LastFullness = GetTotalFullness();
    mode2FullnessStableTime = 0.0;

    state = ArmState.Mode2_Init;
}

void Mode2_Init()
{
    bool rLeft     = MoveRotorToAngle(rotor, DegToRad(MODE2_LEFT_DEG));
    bool pExtPos   = MovePistonTo(pistonExt,   (float)EXT_PISTON_WORK_POS_M, false);
    bool pThirdPos = MovePistonTo(pistonThird, (float)THIRD_PISTON_HOME_POS_M, false);
    bool pFinalPos = MovePistonTo(pistonFinal, (float)FINAL_PISTON_HOME_POS_M, false);
    bool hMainPos  = MoveHingeToAngle(hingeMain, DegToRad(mode2CurrentMainDeg));
    bool hTipPos   = MoveHingeToAngle(hingeTip,  DegToRad(MODE2_HINGE_TIP_DEG));

    drill.Enabled = false;

    if (rLeft && pExtPos && pThirdPos && pFinalPos && hMainPos && hTipPos)
        state = ArmState.Mode2_Lower;
}

void Mode2_Lower(double dt)
{
    bool thirdAtWork =
        pistonThird.CurrentPosition >= THIRD_PISTON_WORK_POS_M - POS_TOL_M;
    bool finalAtWork =
        pistonFinal.CurrentPosition >= FINAL_PISTON_WORK_POS_M - POS_TOL_M;

    if (!thirdAtWork)
        MovePistonTo(pistonThird, (float)THIRD_PISTON_WORK_POS_M, false);
    else if (!finalAtWork)
        MovePistonTo(pistonFinal, (float)FINAL_PISTON_WORK_POS_M, false);

    if (thirdAtWork && finalAtWork)
    {
        pistonThird.Velocity = 0f;
        pistonFinal.Velocity = 0f;

        drill.Enabled = drillEnabledForMode;

        mode2TargetRotorRad = DegToRad(MODE2_RIGHT_DEG);
        mode2SweepDirPositive = true;

        mode2LastFullness = GetTotalFullness();
        mode2FullnessStableTime = 0.0;

        state = ArmState.Mode2_Sweep;
    }
}

void Mode2_Sweep(double dt)
{
    double fullness = GetTotalFullness();

    if (fullness >= FULL_THRESHOLD)
    {
        drill.Enabled = false;
        state = ArmState.Mode2_Return;
        return;
    }

    bool atTarget = MoveRotorToAngle(rotor, mode2TargetRotorRad, MODE2_SWEEP_RPM);

    if (atTarget)
    {
        mode2SweepDirPositive = !mode2SweepDirPositive;
        mode2TargetRotorRad = DegToRad(
            mode2SweepDirPositive ? MODE2_RIGHT_DEG : MODE2_LEFT_DEG
        );

        if (!mode2SweepDirPositive)
        {
            state = ArmState.Mode2_RaiseAngle;
            return;
        }
    }

    MoveHingeToAngle(hingeMain, DegToRad(mode2CurrentMainDeg));
    MoveHingeToAngle(hingeTip,  DegToRad(MODE2_HINGE_TIP_DEG));
    MovePistonTo(pistonExt, (float)EXT_PISTON_WORK_POS_M, false);

    drill.Enabled = drillEnabledForMode;

    double combined = fullness;
    double delta = combined - mode2LastFullness;

    if (delta > FULLNESS_DELTA_EPS)
    {
        mode2LastFullness = combined;
        mode2FullnessStableTime = 0.0;
    }
    else
    {
        mode2FullnessStableTime += dt;

        if (mode2FullnessStableTime >= FULLNESS_STABLE_TIME_S)
        {
            drill.Enabled = false;
            state = ArmState.Mode2_Return;
        }
    }
}

void Mode2_RaiseAngle()
{
    mode2CurrentMainDeg += MODE2_STEP_MAIN_DEG;

    if (mode2CurrentMainDeg < MODE2_END_MAIN_DEG)
        mode2CurrentMainDeg = MODE2_END_MAIN_DEG;

    state = ArmState.Mode2_CheckStopAngle;
}

void Mode2_CheckStopAngle()
{
    if (mode2CurrentMainDeg <= MODE2_END_MAIN_DEG)
    {
        drill.Enabled = false;
        state = ArmState.Mode2_Return;
    }
    else
    {
        state = ArmState.Mode2_Init;
    }
}

void Mode2_Return()
{
    bool rHome      = MoveRotorToAngle(rotor, DegToRad(ROTOR_HOME_DEG));
    bool pFinalHome = MovePistonTo(pistonFinal, (float)FINAL_PISTON_HOME_POS_M, false);
    bool pThirdHome = MovePistonTo(pistonThird, (float)THIRD_PISTON_HOME_POS_M, false);
    bool pExtHome   = MovePistonTo(pistonExt,   (float)EXT_PISTON_HOME_POS_M,   false);
    bool hTipHome   = MoveHingeToAngle(hingeTip,  DegToRad(HINGE_TIP_HOME_DEG));
    bool hMainHome  = MoveHingeToAngle(hingeMain, DegToRad(HINGE_MAIN_HOME_DEG));

    drill.Enabled = false;

    if (rHome && pFinalHome && pThirdHome && pExtHome && hTipHome && hMainHome)
    {
        FullStop();
        RestoreDrive();
        currentMode = GlobalMode.None;
        state = ArmState.Idle;
    }
}


// ======================= MOVEMENT HELPERS =======================

bool MoveHingeToAngle(IMyMotorStator hinge, float targetRad)
{
    if (hinge == null) return true;

    float diff = targetRad - hinge.Angle;

    if (Math.Abs(diff) < DegToRad(ANGLE_TOL_DEG))
    {
        hinge.TargetVelocityRPM = 0f;
        return true;
    }

    float rpm = IsTestMode() ? 2.0f : 0.5f;
    hinge.TargetVelocityRPM = diff > 0 ? rpm : -rpm;

    return false;
}

bool MoveRotorToAngle(IMyMotorStator rotor, float targetRad, float rpm)
{
    if (rotor == null) return true;

    float diff = targetRad - rotor.Angle;

    if (Math.Abs(diff) < DegToRad(ANGLE_TOL_DEG))
    {
        rotor.TargetVelocityRPM = 0f;
        return true;
    }

    rotor.TargetVelocityRPM = diff > 0 ? rpm : -rpm;
    return false;
}

bool MoveRotorToAngle(IMyMotorStator rotor, float targetRad)
{
    return MoveRotorToAngle(rotor, targetRad, IsTestMode() ? 2.0f : 0.5f);
}

bool MovePistonTo(IMyPistonBase piston, float target, bool fast)
{
    if (piston == null) return true;

    float cur = piston.CurrentPosition;
    float diff = target - cur;
    float adiff = Math.Abs(diff);

    if (adiff < POS_TOL_M)
    {
        piston.Velocity = 0f;
        return true;
    }

    float baseSpeed = IsTestMode() ? 2.0f : (fast ? 1.5f : 0.5f);
    float speed = baseSpeed;

    if (adiff < 0.2f) speed = 0.2f;
    if (adiff < 0.05f) speed = 0.05f;

    piston.Velocity = diff > 0 ? speed : -speed;
    return false;
}


// ======================= FORWARD-ONLY ARM CONSTRAINT =======================

float NormalizeAngleRad(float a)
{
    return (float)Math.Atan2(Math.Sin(a), Math.Cos(a));
}

void ApplyForwardConstraint(ref float mainRad, ref float rotorRad)
{
    if (!FORWARD_ONLY_ARM || rotor == null || hingeMain == null)
        return;

    float rotorDeg = RadToDeg(NormalizeAngleRad(rotorRad));

    if (Math.Abs(rotorDeg) > FORWARD_MAX_ROTOR_DEG)
    {
        if (rotorDeg > 0)
            rotorRad -= (float)Math.PI;
        else
            rotorRad += (float)Math.PI;

        mainRad += (float)Math.PI;

        rotorRad = NormalizeAngleRad(rotorRad);
        mainRad  = NormalizeAngleRad(mainRad);

        TRACE($"Forward-only: flipped arm (rotor={RadToDeg(rotorRad):F1} deg, main={RadToDeg(mainRad):F1} deg)");
    }
}


// ======================= FULLNESS HELPERS =======================

double GetTotalCargoFullness()
{
    if (cargos == null || cargos.Count == 0) return 0.0;

    double cur = 0, max = 0;

    foreach (var c in cargos)
    {
        var inv = c.GetInventory();
        cur += (double)inv.CurrentVolume;
        max += (double)inv.MaxVolume;
    }

    if (max <= 0) return 0.0;
    return cur / max;
}

double GetDrillFullness()
{
    if (drill == null)
    {
        TRACE("ERROR: drill block is null");
        return 0.0;
    }

    var inv = drill.GetInventory();
    double cur = (double)inv.CurrentVolume;
    double max = (double)inv.MaxVolume;

    if (max <= 0) return 0.0;
    return cur / max;
}

double GetTotalFullness()
{
    return GetTotalCargoFullness() + GetDrillFullness();
}


// ======================= MATH HELPERS =======================

float DegToRad(float deg) => MathHelper.ToRadians(deg);
float RadToDeg(float rad) => MathHelper.ToDegrees(rad);


// ======================= STATUS DISPLAY =======================

void UpdateStatus(double dt)
{
    Echo(debug);
    debug = "";
    lastStatusTime += dt;
    if (lastStatusTime < STATUS_INTERVAL_S) return;
    lastStatusTime = 0;

    var sb = new System.Text.StringBuilder();

    sb.AppendLine("== Rover Auto Excavation (Forward-Safe) ==");

    if (!string.IsNullOrEmpty(lastAbortReason))
        sb.AppendLine("ABORT: " + lastAbortReason);
    else
        sb.AppendLine("ABORT: (none)");

    sb.AppendLine($"Mode            : {currentMode}");
    sb.AppendLine($"State           : {state}");
    sb.AppendLine($"STOP            : {(stopRequested ? "YES" : "NO")}");
    sb.AppendLine($"Drill           : {(drill?.Enabled ?? false ? "ON" : "OFF")}");

    if (rotor != null)      sb.AppendLine($"Rotor Angle     : {RadToDeg(rotor.Angle):F1} deg");
    if (hingeMain != null)  sb.AppendLine($"Hinge Main      : {RadToDeg(hingeMain.Angle):F1} deg");
    if (hingeTip != null)   sb.AppendLine($"Hinge Tip       : {RadToDeg(hingeTip.Angle):F1} deg");

    if (pistonExt != null)    sb.AppendLine($"Piston Upper    : {pistonExt.CurrentPosition:F2} m");
    if (pistonThird != null)  sb.AppendLine($"Piston Third    : {pistonThird.CurrentPosition:F2} m");
    if (pistonFinal != null)  sb.AppendLine($"Piston Final    : {pistonFinal.CurrentPosition:F2} m");

    if (ctrl != null)
    {
        var massInfo = ctrl.CalculateShipMass();
        sb.AppendLine($"Speed           : {ctrl.GetShipSpeed():F1} m/s");
        sb.AppendLine($"Mass (phys)     : {massInfo.PhysicalMass:F0} kg");
        sb.AppendLine($"Gravity         : {ctrl.GetNaturalGravity().Length():F2} m/s^2");
    }

    double fullness = GetTotalFullness();
    sb.AppendLine($"Cargo+DrillFull : {(fullness * 100):F1}%");

    sb.AppendLine($"Wheels          : {wheels.Count}");
    sb.AppendLine($"Gyros           : {gyros.Count}");
    sb.AppendLine($"Thrusters       : {downThrusters.Count}");

    lcd.WriteText(sb.ToString(), false);
}


// ======================= PARSE MANUAL MOVE =======================

void ParseManualMoveCommand(string arg)
{
    var parts = arg.Split(' ');
    if (parts.Length < 7) return;

    float mainDeg, tipDeg, rotorDeg;
    float pExt, pThird, pFinal;

    if (!float.TryParse(parts[1], out mainDeg)) mainDeg = 0f;
    if (!float.TryParse(parts[2], out tipDeg))  tipDeg  = 0f;
    if (!float.TryParse(parts[3], out rotorDeg)) rotorDeg = 0f;

    if (!float.TryParse(parts[4], out pExt))   pExt   = 0f;
    if (!float.TryParse(parts[5], out pThird)) pThird = 0f;
    if (!float.TryParse(parts[6], out pFinal)) pFinal = 0f;

    manualMainRad  = DegToRad(mainDeg);
    manualTipRad   = DegToRad(tipDeg);
    manualRotorRad = DegToRad(rotorDeg);

    manualPExt     = pExt;
    manualPThird   = pThird;
    manualPFinal   = pFinal;
}


// ======================= TEST MODE =======================

void AdvanceTestPose()
{
    switch (testPose)
    {
        case TestPose.VerticalHome:
            lcd.WriteText("Pose 1: VerticalHome\nChecks: rotor=0, hinges straight, pistons retracted.");
            RunMove(-90, 0, 0, 0, 0, 0);
            testPose = TestPose.RotorLeft;
            break;

        case TestPose.RotorLeft:
            lcd.WriteText("Pose 2: RotorLeft\nChecks: rotor left sweep symmetry.");
            RunMove(-90, 0, 60, 0, 0, 0);
            testPose = TestPose.RotorRight;
            break;

        case TestPose.RotorRight:
            lcd.WriteText("Pose 3: RotorRight\nChecks: rotor right sweep symmetry.");
            RunMove(-90, 0, 120, 0, 0, 0);
            testPose = TestPose.Folded;
            break;

        case TestPose.Folded:
            lcd.WriteText("Pose 4: Folded\nChecks: hinge folding geometry.");
            RunMove(-90, 90, 0, 0, 0, 0);
            testPose = TestPose.ExtendedForward;
            break;

        case TestPose.ExtendedForward:
            lcd.WriteText("Pose 5: ExtendedForward\nChecks: arm straight forward alignment.");
            RunMove(0, 0, 0, 0, 0, 0);
            testPose = TestPose.PistonExt;
            break;

        case TestPose.PistonExt:
            lcd.WriteText("Pose 6: PistonExt\nChecks: upper piston extends straight.");
            RunMove(-90, 0, 0, 2, 0, 0);
            testPose = TestPose.PistonThird;
            break;

        case TestPose.PistonThird:
            lcd.WriteText("Pose 7: PistonThird\nChecks: third piston extends straight.");
            RunMove(-90, 0, 0, 0, 2, 0);
            testPose = TestPose.PistonFinal;
            break;

        case TestPose.PistonFinal:
            lcd.WriteText("Pose 8: PistonFinal\nChecks: final piston extends straight.");
            RunMove(-90, 0, 0, 0, 0, 2);
            testPose = TestPose.FullExtension;
            break;

        case TestPose.FullExtension:
            lcd.WriteText("Pose 9: FullExtension\nChecks: entire chain straight, no twist.");
            RunMove(-90, 0, 0, 2, 2, 2);
            testPose = TestPose.Done;
            break;

        case TestPose.Done:
            lcd.WriteText("Unit Test Complete.\nAll poses executed.");
            testPose = TestPose.None;
            currentMode = GlobalMode.None;
            break;
    }
}

void RunMove(float mainDeg, float tipDeg, float rotorDeg, float pExt, float pThird, float pFinal)
{
    manualMainRad  = DegToRad(mainDeg);
    manualTipRad   = DegToRad(tipDeg);
    manualRotorRad = DegToRad(rotorDeg);

    manualPExt     = pExt;
    manualPThird   = pThird;
    manualPFinal   = pFinal;

    ApplyForwardConstraint(ref manualMainRad, ref manualRotorRad);

    state = ArmState.ManualMove;
}


// ======================= BLOCK FINDING =======================

void FindBlocks(bool fullScan = false)
{
    rotor       = GridTerminalSystem.GetBlockWithName(ROTOR_NAME)        as IMyMotorStator;
    pistonExt   = GridTerminalSystem.GetBlockWithName(PISTON_EXT_NAME)   as IMyPistonBase;
    pistonThird = GridTerminalSystem.GetBlockWithName(PISTON_THIRD_NAME) as IMyPistonBase;
    pistonFinal = GridTerminalSystem.GetBlockWithName(PISTON_FINAL_NAME) as IMyPistonBase;

    hingeMain   = GridTerminalSystem.GetBlockWithName(HINGE_MAIN_NAME)   as IMyMotorStator;
    hingeTip    = GridTerminalSystem.GetBlockWithName(HINGE_TIP_NAME)    as IMyMotorStator;

    drill       = GridTerminalSystem.GetBlockWithName(DRILL_NAME)        as IMyShipDrill;

    cargos.Clear();
    if (!string.IsNullOrEmpty(CARGO_NAME))
    {
        var c = GridTerminalSystem.GetBlockWithName(CARGO_NAME) as IMyCargoContainer;
        if (c != null) cargos.Add(c);
    }
    else
    {
        GridTerminalSystem.GetBlocksOfType<IMyCargoContainer>(cargos, c => c.CubeGrid == Me.CubeGrid);
    }

    List<IMyShipController> ctrls = new List<IMyShipController>();
    GridTerminalSystem.GetBlocksOfType<IMyShipController>(ctrls, c => c.CubeGrid == Me.CubeGrid);

    ctrl = null;
    foreach (var c in ctrls)
    {
        if (c.IsMainCockpit)
        {
            ctrl = c;
            break;
        }
    }
    if (ctrl == null && ctrls.Count > 0)
        ctrl = ctrls[0];

    FindWheels();

    gyros.Clear();
    GridTerminalSystem.GetBlocksOfType<IMyGyro>(gyros, g => g.CubeGrid == Me.CubeGrid);

    downThrusters.Clear();
    GridTerminalSystem.GetBlocksOfType<IMyThrust>(downThrusters, t => t.CubeGrid == Me.CubeGrid);
}

bool EnsureBlocks()
{
    if (rotor == null || pistonExt == null || pistonThird == null || pistonFinal == null ||
        hingeMain == null || hingeTip == null || drill == null || ctrl == null)
    {
        FindBlocks();
    }

    return (rotor != null && pistonExt != null && pistonThird != null && pistonFinal != null &&
            hingeMain != null && hingeTip != null && drill != null && ctrl != null);
}
